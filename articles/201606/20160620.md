# CPUの創りかた(10): おまけ、アセンブラ

CPU自体は前回までで完成したので、次のネタに行ってもよかったのだが、

* CPU(の実行プログラム)に与えるのがマシンコードだと、いちいち
  ハンドアセンブルするのが面倒くさい。
* 別件でパーサを書く必要がありParsecライブラリに興味を持っていたので
  そのうち勉強しようとしていた。

という理由により、今回はおまけとして簡易アセンブラを作ってみよう。

#### まずは文法の定義から

このCPU(TD4)は命令数が非常に少ないので、何となれば単なる文字列
変換でもよかったが、Parsecの勉強も兼ねているからそこはちゃんと
文法の定義から入らなければなるまい。

文法定義とくれば(わたし的には)BNFだろう。大学時代にわからないなりに
適当な文法を定義して遊んでいたのを思い出す。その頃の記憶を頼りに
BNFで書き始めたのだが、どうやら世間には
(EBNF)[https://ja.wikipedia.org/wiki/EBNF]というのがあるようなので
どうせならこちらにしよう、BNFの問題を解決しているということだし。

ところでアセンブリ言語(ニーモニック?)の文法はどのように定義したら
いいのだろう? と調べたら、
(こういうの)[http://www.nak.ics.keio.ac.jp/class/asm/t11/ast11man.pdf]が
見つかった。作りたいのはこれよりだいぶ簡易なものなので、ありがたく
参考にさせていただいた。EBNFはこれが初めてなので間違っている可能性は
高いがとりあえず次のように定義してみた。

```
# EBNF for TD4 assembler

  program = instcode , { instcode } ;

  instcode = ( code2 | code1 ) , linefeed ;

  code2 = inst2, space, operand2 ;
  code1 = inst1, space, operand1 ;

  inst2 = 'add' | 'mov' ;
  inst1 = 'in' | 'out' | 'jnc' | 'jmp' ;

  operand2 = register , "," , operand1 ;
  operand1 = register | imdata ;

  register = 'a' | 'b' ;

  imdata = 4 * digit2 ;
  digit2 = "0" | "1" ;

  space = white space , { white space } ;
  white space = '\x20' | '\x09' ;

  linefeed = '\x0a' | ( '\x0d' , '\x0a' ) ;
```

2オペランド命令のANDとMOV、それ以外の命令でオペランドの定義が異なる。
あとはレジスタとか直値とかを定義していけばよさそう。ひとまず形になった
気がするので先に進もう。

#### パーサの前に

どうもParsecを使えば、EBNF(BNF)の定義からある程度容易にパーサの
プログラムに落とし込める、という話があるらしい。ならEBNFができている
のだから簡単に作れるよね、と思ったのは甘すぎだった。

まず参考となるWebサイトをいろいろ読んでみて、こう作ればよさそうという
感触を得たかったのだが、ちっとも理解できなかった。今なら何を理解できて
いなかったのか分かるが、当初は本当にわからなかったのだ。

要は、ソースをパーサが字句解析したあと、それをどのようにして次の処理
(意味解析、コード生成)に結びつけたらいいのかイメージが湧かなかったため。
Web上でありがちな例は、"add 1,2"みたいなのが入力されたら、"add"を
解析して「"add"という文字列を返す」みたいなやつだ。文字列を解析したい
のに解析結果が文字列ならそれをさらに解釈する処理が必要で堂々巡りに
思えてしまった。転機は(この記事)[https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec]。
この記事では明快に「返す値を型で定義している」。

つまりパーサからは「構文木」かそれに類する構造化されたデータが出力されるのだ。
それをまず考えて(定義して)おかないとパーサが書けるわけがない。
ではどのような構造のデータがあればマシンコードに変換できるかを考えてみる。

TD4の命令は、命令コードと1つまたは2つのオペランドからなる(オペランドなしの
命令は無い)。そこで、これらを組で表すことにする。最終的にはこう。

```haskell
data Inst = Add | Mov | In | Out | Jnc | Jmp deriving (Enum, Show)
data Operand = RegA | RegB | Imdata String deriving Show

type Mnemonic = (Inst, (Operand, Maybe Operand))
```

`Mnemonic`は二重の組だ。命令コードとオペランドの組からなる。
オペランドの組は、一つ目は必ず存在するので普通に`Operand`で、
二つ目は無いかもしれないので`Maybe`型とした。オペランドはA,Bレジスタか
直値の三種類しかない。パーサはソースを解析してMnemonicを命令の数だけ
リストにして返してくれればよいのだ。

#### パーサを書く

ではパーサを書いてみようと思う。何となくだが末端から作って積み重ねて
行った方がわかりやすそうなので、個々のオペランドから始める。まずは
直値(immediate data)から。

```haskell
-- EBNF
--   imdata = 4 * digit2 ;
--   digit2 = "0" | "1" ;

imdata :: Parser Operand
imdata = do
  im <- count 4 (oneOf "01")
  return $ Imdata im
```

先に定義したように、直値も`Operand`型の一つなのでパーサの型が
`Parser Operand`になっている。直値は二進数だけを扱うことにし、
かならず4桁と決めた。なので、`oneOf`で0か1に限定し、それを4つ
連続して取り出したら返すようにした。EBNFの定義と見比べると、
決めた通りにプログラムを書けばよいのがわかる。

同様に、A,Bレジスタはこうなる。

```haskell
-- EBNF
--   register = 'a' | 'b' ;

register :: Parser Operand
register = do
  rg <- (regA <|> regB)
  return rg

regA :: Parser Operand
regA = do
  rg <- string "a"
  return $ RegA

regB :: Parser Operand
regB = do
  rg <- string "b"
  return $ RegB
```

AかBかの区別をつけるため、それぞれ別にパーサを定義し、それを`<|>`で
合わせてレジスタのパーサとした。

あとは同様にEBNFをもとに以下のようなパーサを作った。

```haskell
program :: Parser [(Inst, (Operand, Maybe Operand))]
program = do
  pg <- many1 $ instcode
  return pg

instcode :: Parser (Inst, (Operand, Maybe Operand))
instcode = do
  cd <- code2 <|> code1
  many1 $ oneOf "\r\n"
  return cd

code2 :: Parser (Inst, (Operand, Maybe Operand))
code2 = do
  in2 <- inst2
  many1 space
  op2 <- operand2
  return (in2, op2)

code1 :: Parser (Inst, (Operand, Maybe Operand))
code1 = do
  in1 <- inst1
  many1 space
  op1 <- operand1
  return (in1, (op1, Nothing))

inst2 :: Parser Inst
inst2 = do
  i2 <- (string "add" <|> string "mov")
  let i = if i2 == "add" then Add else Mov
  return i

inst1 :: Parser Inst
inst1 = do
  i1 <- (string "in" <|> string "out" <|>
         try (string "jnc") <|> (string "jmp"))
  let i = case i1 of
            "in"  -> In
            "out" -> Out
            "jnc" -> Jnc
            "jmp" -> Jmp
  return i

operand2 :: Parser (Operand, Maybe Operand)
operand2 = do
  op2 <- register
  char ','
  op1 <- operand1
  return $ (op2, Just op1)

operand1 :: Parser Operand
operand1 = do
  op1 <- (register <|> imdata)
  return op1
```

EBNFの定義と見比べれば、それぞれ何をしているかは分かると思う。
ではテストしてみよう。テスト用プログラムはざっと以下のような感じ。

```haskell
module Main where

import Control.Applicative hiding ((<|>))
import Data.Char
import Text.Parsec
import Text.Parsec.String
import Text.Parsec.Char

(型、パーサ定義)

main :: IO ()
main = do
  parseTest inst2 "add"
  parseTest inst2 "mov"
  parseTest inst2 "abc"
  parseTest register "a"
  parseTest register "b"
  parseTest register "c"
  parseTest imdata "0100"
  parseTest imdata "10100"
  parseTest imdata "1012"
  parseTest operand1 "aa"
  parseTest operand2 "a 1100"
  parseTest code2 "add a,b"
  parseTest code2 "mov a,0011"
  parseTest code1 "jmp 1011"
  parseTest code1 "in  b"
  parseTest code1 "in  a"
  parseTest code1 "in  0110"
  parseTest instcode "add a,b\n"
  parseTest instcode "add a,b\r\n"
  parseTest instcode "add a,a"
  parseTest instcode "jmp 1100\r\n"
```

このように、パーサに食わせてみたい文字列とそれを処理するパーサ関数を
組みにして与えればいいようだ。パーサの解析に失敗した(=文法にそぐわない)
場合はエラーが返るのですぐわかる。













