# CPUの創りかた(2): decorderとmultiplexer

前回は基本的な論理ゲートを作った。今回作ろうとしているCPU(TD4)は以下の本で
説明されているが、論理回路の本格的なところはROMの作成からだ。

<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=eijian-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4839909865" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

ROMの実装において、まずアドレスを指定するためにdecorder、各番地から出てくる
信号を統合するのにmultiplexerを用いるようだ。

ということで今回は、少し複雑な論理回路としてdecorderとmultiplexerを作ろう。

#### decorder

ガッコウで習ったはずだが、この本を読むまですっかり忘れていた。
decorderは$n$[bit]の入力に対し、それを数字と見て数字に該当する出力のみ
ONにするようなものだ。今回作るのは不論理なので一つだけL、残りはHになる。
簡単な2[bit]の場合の真理値表は次の通り。

|A|B|C0|C1|C2|C3|
|-|-|--|--|--|--|
|L|L|L |H |H |H |
|H|L|H |L |H |H |
|L|H|H |H |L |H |
|H|H|H |H |H |L |

これを論理回路にすると下のようになる。

（2bit decorder)

真理値表をそのままにhaskellのコードにしてみよう。
その前に、前回論理回路の入出力の方を`Bool`の別名として`Bin`と定義した。
実際の値は`True`と`False`になるが、少し長くてわかりにくいのでsHIとsLOを
定義しておく(state HIGH、state LOWのつもり）。

```haskell
sHI = True  :: Bin
sLO = False :: Bin

(version 1)

lc_decorder2 :: LogicCircuit
lc_decorder2 (False:False:_) = [sLO, sHI, sHI, sHI]
lc_decorder2 (True:False:_)  = [sHI, sLO, sHI, sHI]
lc_decorder2 (False:True:_)  = [sHI, sHI, sLO, sHI]
lc_decorder2 (True:True:_)   = [sHI, sHI, sHI, sLO]
```

できた。とても簡単だ。上の真理値表をそのままコードに落とすだけだ・・・。
しかしROMを作るときは2[bit]ではなく4[bit]が必要らしい。となると16個の
要素を持つリストが16個定義されるわけだ。邪魔くさくて見にくいのは目に
見えている。ということで、真理値表を参考に、同等のリストを生成する
コードにしてみよう。

まず入力のn[bit]を数字に変換し、2[bit]なら4個、4[bit]なら16個の
Bin要素を持つリストを、変換した数字のところだけL、それ以外はHに
なるよう作ればよいだろう。

入力を数字に直す関数は次の通り。最初の方を下位ビットとして、
上位ビットから1なら足し合わせて二倍する、を繰り返す。


```haskell
bin2int :: [Bin] -> Int
bin2int [] = 0
bin2int (x:xs) = a + 2 * bin2int xs
  where
    a = if x == sHI then 1 else 0
```

これで入力を数字に換えることができた。今度はその数字をiとするときに
i番目だけLになるようなBinのリストを作ろう。

```haskell
decorder' :: Int -> LogicCircuit
decorder' b xs = map (\x -> if x == n then sLO else sHI) [0..mx]
  where
    mx = 2^b - 1
    n = bin2int (take b xs)
```

第一引数はビット数、そのあとに数字のもとになるビット列を与える。
たとえば、`b=2, xs=[sLO, sHI]`だと、2だ（先頭が下位ビット）。
あとは0から3までの数のリストを基に、入力された数と一致するときにL
それ以外はHに変換すればよい。出力は`[sHI, sHI, sLO, sHI]`になるはずだ。

これで任意のn[bit]のdecorderができた！2[bit], 4[bit]の場合は以下の
様になるだろう。

```haskell
(version 2)

lc_decorder2 :: LogicCircuit
lc_decorder2 = decorder' 2


lc_decorder4 :: LogicCircuit
lc_decorder4 = decorder' 4
```

プログラムらしくなってきた！

・・・いやいや、これは趣旨が違うだろう・・・

今回のネタは、半田ごてとかを使った電子工作ができないから、せめて
ソフトウェアで論理回路をシミュレーションしようとしたのだ。上記の
コードには論理ゲートがこれっぽっちも入っていないではないか！
やり直しだ。。。

先に2[bit]の場合の回路図を示した。これをそのまま実装しようでは
ないか。前回の論理ゲートを使って。

```haskell
(version 3)

lc_decorder2 :: LogicCircuit
lc_decorder2 (a:b:_) = [y0, y1, y2, y3]
  where
    [a', b'] = lc_not [a, b]
    [y0] = lc_nand [a', b']
    [y1] = lc_nand [a, b']
    [y2] = lc_nand [a', b]
    [y3] = lc_nand [a, b]
```

回路図のままなので説明のしようもないかと思う。これだけでも論理回路を
作っている気になるのが楽しいところだ（自分だけかもしれないが）。
本当にちゃんと動いているのかテストしよう。先に示した最初のバージョン
（真理値表をそのまま直接コードにしたもの）と結果を比較するのだ。
同じ名前にできないので、version 1にはダッシュを付けた。

```haskell
{- |
2bit decorder

>>> lc_decorder2 [sLO, sLO] == lc_decorder2' [sLO, sLO]
True
>>> lc_decorder2 [sHI, sLO]  == lc_decorder2' [sHI, sLO]
True
>>> lc_decorder2 [sLO, sHI]  == lc_decorder2' [sLO, sHI]
True
>>> lc_decorder2 [sHI, sHI]   == lc_decorder2' [sHI, sHI]
True
-}
```

これをdoctestで実行してみるとちゃんとテストが通る！嬉しい！







