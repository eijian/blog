レイトレーシング(1): 第一ステップの設定とベクトル定義

Haskellは数学と関連があるというような話をちょくちょく見ることがある。
圏論がどうとか数学的な概念が…といったところは筆者にはわからないが、
ソース（見た目）はかなり数学っぽいと思う。実際これが一番Haskellに
のめり込んでいる理由かもしれない。この簡潔さは素晴らしい。
ということで、今回からレイトレーシングに挑戦する。
(単に数学的、物理学的に基礎を置くアルゴリズムだからというだけ)

手元にこんな本があるので
[フォトンマッピング]
古典的なレイトレーシングソフトは作ったことがあるので、今回は
フォトンマッピングに手を出してみようと思う。そういうことだから、
完成できる保証はない。なお、ここでは理論の詳細には触れない。
レイトレーシングのアルゴリズムや実装については
[ここ](http://kagamin.net/hole/edupt/index.htm)を参照するとよいかもしれない。

#### 第一ステップの設定

フォトンマッピング法に詳しいわけではないので、大ウソの連発かもしれない
ことはあらかじめ言い訳しておく。

さてこの手法は第一フェーズでフォトンマップを作成し、第二フェーズで
レイトレーシングする、二段階アルゴリズムであるところ。ただし第二フェーズは
不通のレイトレではなくフォトンマップから光が到達する量を「推定」する。

最初から超リアルな画像を生成できるものを作るのは無理なので、簡単なものを
作って少しずつ肉付けしていけばいいだろう（可能なら）。
第一ステップではだいぶ単純化した仕様にしてまずは動くものを作ろう。
以下が最初の概略の仕様だ。

* 光源は点光源だけにする。
* 物体表面は拡散反射のみ（鏡面反射・屈折は無視）
* フォトンの追跡は反射を無視（=拡散反射による「綺麗な」効果はお預け）
* 物体は球と無限平面のみ
* 材質（というか色）は単色

これが必要十分なのか今の時点ではよくわからないが、とりあえずは進めて
みよう。

#### ベクトル演算

レイトレーシングの処理は、ほとんどが3次元ベクトルの演算と光量(輝度）の
演算で占められている。ゆえにベクトルの定義は処理速度に直結するので
とても重要だ。とはいえ別に商用でもないのでわかりやすくしよう。

ベクトルの定義は、リストを使う、タプルを使う、独自型を作る方法を思い
つくが、リストを使うと各種のベクトル演算にリストの便利な関数群を使える
のでとてもわかりやすい。しかもこれら3種類で処理速度を計測してみたが、
リストと独自型はどっこいどっこいだったのでリストがいいなぁと考えて
いたが、リストだと型クラスで縛りを設けられなかった。newtypeで定義
してうまくリストの特性や関数を継承できたらいいのだろうが、上手く
いかない。仕方ないので今回は独自型で行く。どうせベクトル演算の内部
処理は隠蔽されるので、うまい方法が見つかれば変えれば良い。

主要なベクトル演算は型クラスで定義しておくと2次元ベクトルや行列など
似たような型を定義するのにも使えそうである。どちらかというとベクトルは
行列の特殊なものと考えれば、型クラスは

> BasicMatrix => Matrix, Vector

という親子関係にしたほうがよさそう。BasicMatrixに行列やベクトルに
共通な基本的な演算(関数)を定義し、特有の演算はそれぞれMatrixと
Vectorクラスに定義するようにしよう。まずBasicMatrixで定義するのは
次の演算だ。

[tex:{
a + b
a - b
|a| (norm)
s * a (scale)
}]


