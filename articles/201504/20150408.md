レイトレーシング(1): 第一ステップの設定とベクトル定義

Haskellは数学と関連があるというような話をちょくちょく見ることがある。
圏論がどうとか数学的な概念が…といったところは筆者にはわからないが、
ソース（見た目）はかなり数学っぽいと思う。実際これが一番Haskellに
のめり込んでいる理由かもしれない。この簡潔さは素晴らしい。
ということで、今回からレイトレーシングに挑戦する。
(単に数学的、物理学的に基礎を置くアルゴリズムだからというだけ)

手元にこんな本があるので
[フォトンマッピング]
古典的なレイトレーシングソフトは作ったことがあるので、今回は
フォトンマッピングに手を出してみようと思う。そういうことだから、
完成できる保証はない。なお、ここでは理論の詳細には触れない。
レイトレーシングのアルゴリズムや実装については
[ここ](http://kagamin.net/hole/edupt/index.htm)を参照するとよいかもしれない。

#### "バージョン1"の設定

フォトンマッピング法に詳しいわけではないので、大ウソの連発かもしれない
ことはあらかじめ言い訳しておく。

さてこの手法は第一フェーズでフォトンマップを作成し、第二フェーズで
レイトレーシングする、二段階アルゴリズムであるところ。ただし第二フェーズは
普通のレイトレではなくフォトンマップから光が到達する量を「推定」する。

最初から超リアルな画像を生成できるものを作るのは無理なので、簡単なものを
作って少しずつ肉付けしていけばいいだろう（可能なら）。
バージョン1ではだいぶ単純化した仕様にして、まずは動くものを作ろう。
以下が最初の仕様だ。

* 光源は点光源だけにする。
* 物体表面は拡散反射のみ（鏡面反射・屈折は無視）
* フォトンの追跡は反射を無視（=相互拡散反射による効果はお預け）
* 物体は球と無限平面のみ
* 材質（というか色）は単色

これが必要十分なのか今の時点ではよくわからないが、とりあえずは
進めてみよう。

#### ベクトル演算

レイトレーシングの処理は、ほとんどが3次元ベクトルか光量(輝度）の
演算で占められている。まずはベクトル演算のモジュールを作ろう。
代数に関するモジュールなので名前をAlgebraにしよう。
開発用ディレクトリの基本てきな構造は以前に書いた通り。
今回は`src`ディレクトリの下に`Ray`というディレクトリを作って
その中にソースファイルを作ることにする。トップディレクトリから見ると
`src/Ray/Algebra.hs`だ。

主要なベクトル演算は型クラスで定義しておくと2次元ベクトルや行列など
似たような型を定義するのにも使えそうである。どちらかというとベクトルは
行列の特殊なものと考えれば、型クラスは

```
 BasicMatrix --> Matrix, Vector
```

という親子関係にしたほうがよさそう。`BasicMatrix`に行列やベクトルに
共通な基本的な演算(関数)を定義し、特有の演算はそれぞれMatrixと
`Vector`クラスに定義するようにしよう。まず`BasicMatrix`で基本的な
演算を定義する。加減算、スカラー倍、スカラー除算、ノルムにしよう。
他に必要なものがあれば出てきてから追加する。なお、こっそり`Show`クラスと
`Eq`クラスの子にしておく。
(実はこの歳になって初めてノルムにも色々な種類があると知った。
ただここでは一般的(?)な、ベクトルで長さを意味するノルムとしよう。）

```haskell
class (Show a, Eq a) => BasicMatrix a where
  madd :: a -> a -> a           -- 加算
  msub :: a -> a -> a           -- 減算
  mscale :: Double -> a -> a    -- スカラー倍
  mdiv   :: a -> Double -> a    -- スカラー除算
  norm :: a -> Double           -- ノルム
  nearlyEqual :: a -> a -> Bool -- ≒

class (BasicMatrix a) => Vector a where
  dot :: a -> a -> Double       -- 内積
  normalize :: a -> Maybe a     -- 正規化
  normalize a = a `mdiv` (norm a)
  square :: a -> Double         -- 二乗
  square a = a `dot` a
```

`Vector`クラスの定義中、正規化と二乗については処理が共通なので
実装も書いてしまうことにする。`normalize`の結果が`Maybe`なのは
ベクトルの要素がすべて0、つまり長さが0の場合は0除算になるからだ。
のちのちMaybe型に関連する関数を使うためには`Data.Maybe`
モジュールをimportしないといけない。今のうちに入れておく。

```haskell
import Data.Maybe
```

なお、`Matrix`(行列)は将来的には使うが、とりあえず今は無視する。

次に三次元ベクトル型を定義しよう。`Vector3`だ。

```haskell
data Vector3 = Vector3 Double Double Double

instance Show Vector3 where
  show (Vector3 x y z) = "(" ++ (show x) ++ "," ++ (show y) ++ "," ++ (show z) ++ ")"

instance Eq Vector3 where
  (==) (Vector3 ax ay az) (Vector3 bx by bz) = (ax == bx) && (ay == by) && (az == bz)

instance Matrix Vector3 where
  madd (Vector3 ax ay az) (Vector3 bx by bz) = Vector3 (ax + bx) (ay + by) (az + bz)
  msub (Vector3 ax ay az) (Vector3 bx by bz) = Vector3 (ax - bx) (ay - by) (az - bz)
  




