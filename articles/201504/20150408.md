レイトレーシング(1): 第一ステップの設定とベクトル定義

Haskellは数学と関連が深いというような話をちょくちょく見ることがある。
圏論がどうとか数学的な概念が…といったところは筆者にはわからないが、
少なくともソースはかなり数学っぽいとおもう。ここが一番Haskellに
のめり込んでいる理由かもしれない。C系統の'{','}'でくくるところとか
やたら無駄な記述が多いのにはもう疲れた。Haskellの何と簡潔なことか。

ということで、(脈略がないが)今回からレイトレーシングに挑戦する。
単に数学的、物理学的なアルゴリズムだというだけだが。
ただ、レイトレーシングのソフト自体は昔から何度か作ったことが
あるので自分にとっては目新しくはない。何十年も前に"Oh!PC"という
雑誌にBASICで書かれたレイトレのプログラムにいたく感動した時からの
付き合いだ。

ただ、手元にこんな本があるので
[フォトンマッピング]
これまでの単純かつ古典的なレイトレーシングではなく、いっそのこと
フォトンマッピングに手を出してみようかと思う。そういうことだから、
完成する保証はないし詳細は本を参照のこと。ここでは理論の詳細には
触れない。なおレイトレーシングのアルゴリズムや実装については
[ここ](http://kagamin.net/hole/edupt/index.htm)を参照するとよいかもしれない。

#### 第一ステップの設定

フォトンマッピング法に詳しいわけではないので嘘が大量に含まれている
可能性がある。あらかじめ言い訳しておく。

さてこの手法の肝はphase1でフォトンマップを作成し、phase2でレイ
トレーシングする二段階アルゴリズムであるところかなと。ただしphase2は
ただのレイトレではなくフォトンマップから光が到達する量を「推定」する。

最初から超リアルな画像を生成できるものを作るのは大変なので、第一ステップ
ではだいぶ単純化した仕様にしてまずは動くものを作ろう。肉付けは後で
（可能なら）頑張ろう。以下が最初の仕様だ。

* 光源は球光源だけにする。
* 物体表面は拡散反射のみ（鏡面反射・屈折は無視）
* フォトンの追跡は反射を無視（=拡散反射による「綺麗な」効果はお預け）
* 物体は球と無限平面のみ
* 材質（というか色）は単色

これが必要十分なのか今の時点ではよくわからないが、とりあえずは進めて
みよう。

#### ベクトル演算

レイトレーシングの処理は、ほとんどが3次元ベクトルの演算と光量(輝度）の
演算で占められている。ゆえにベクトルの定義は処理速度に直結するので
とても重要だ。とはいえ別に商用でもないのでわかりやすくしよう。

ベクトルの定義は、リストを使う、タプルを使う、独自型を作る方法を思い
つくが、リストを使うと各種のベクトル演算にリストの便利な関数群を使える
のでとてもわかりやすい。しかもこれら3種類で処理速度を計測してみたが、
リストと独自型はどっこいどっこいだったのでリストがいいなぁと考えて
いたが、リストだと型クラスで縛りを設けられなかった。newtypeで定義
してうまくリストの特性や関数を継承できたらいいのだろうが、上手く
いかない。仕方ないので今回は独自型で行く。どうせベクトル演算の内部
処理は隠蔽されるので、うまい方法が見つかれば変えれば良い。

主要なベクトル演算は型クラスで定義しておくと2次元ベクトルや行列など
似たような型を定義するのにも使えそうである。どちらかというとベクトルは
行列の特殊なものと考えれば、型クラスは

> BasicMatrix => Matrix, Vector

という親子関係にしたほうがよさそう。BasicMatrixに行列やベクトルに
共通な基本的な演算(関数)を定義し、特有の演算はそれぞれMatrixと
Vectorクラスに定義するようにしよう。まずBasicMatrixで定義するのは
次の演算だ。

[tex:{
a + b
a - b
|a| (norm)
s * a (scale)
}]


