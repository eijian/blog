レイトレーシング(2): ユニットテストなど

#### ユニットテスト

前回定義したベクトルのモジュールをテストしたい。xUnitみたいなのは
ないかと思ったら、やはりHaskell用にはHUnitがあるらしい。
しかし、JUnit等と同様にテストコードを別ファイルで定義したり
一つ一つ値を試すテストを書いてしないといけないようだ。
これまでxUnit系を少しかじったことがあるが、結構邪魔くさい。

一方、Haskell勉強用にと買った[]には、QuickCheckなるものがあると
書いてある。これは値をいちいち記述してその結果と比べて、みたいな
書き方ではなく、その関数がどうふるまうべきかを書いていくようだ。
先のベクトルモジュールで言えば、「`normalize`(正規化)したベクトルの
大きさは1.0になる」ということ。

でもQuickCheckでも、テスト用のコードを別に書かないといけないなぁと
思っていたら、尊敬するkazu-yamamotoさんのブログにいいことが
[書いて]あるではないか。doctestにQuickCheckを組み合わせるということだ。
これならソースファイルにテストコードを記述でき、複数のテストの
同時実行もファイルを一つだけ用意するだけみたい。
(難しいことはよくわからないので、とりあえずHSpecは無視)

#### ベクトルモジュールをいじる

#### (1) 位置ベクトルと方向ベクトル

三次元ベクトル`Vector3`を定義したが、実用的にはもう少し分類しておきたい。
つまり、位置ベクトル(positional vector)と方向ベクトル(directional vector)に
分けて管理できるようにしたい。そこで、`Vector3`に別名をつけよう。

```haskell
type Position3 = Vector3
type Direction3 = Vector3
```

これだけだと名前だけの話だ。今回のプログラムでは方向ベクトルは必ず
正規化されているもの、という制約をつけよう（ただ、邪魔くさそうなので
厳密にはやらないけど）。そのために、生成時に必ず正規化されるように
`initDir`を用意する。あとあとのため、ゼロベクトル、単位ベクトルも
合わせて定義しておこう。形だけだが、位置ベクトルにも`initPos`を用意しよう。

```haskell
o3 = Vector3 0 0 0    -- ゼロベクトル
ex3 = fromJust $ initDir 1 0 0 -- 単位ベクトル(x)
ey3 = fromJust $ initDir 0 1 0 -- 単位ベクトル(x)
ez3 = fromJust $ initDir 0 0 1 -- 単位ベクトル(x)

initDir :: Double -> Double -> Double -> Maybe Direction3
initDir x y z
  | v == o3   = Nothing
  | otherwise = Just (normalize v)
  where
    v = Vector3 x y z

initPos :: Double -> Double -> Double -> Position3
initPos x y z = Vector3 x y z

```

`initDir`の結果に`Maybe`を使っているのは、引数が全部ゼロの場合が
あり得るから。これでは方向ベクトルにできない。


#### (2) 公開するもの、しないもの

中には他のモジュールには見せたくない関数なども含まれている（としよう）。
Javaでいうprivateメソッドとかのようなものだな。
このように外部に晒したくないものがある場合は、見せてよいものだけを
列挙したらいいらしい。モジュールの先頭で列挙するだけなので簡単だった。

```haskell
module Ray.Algebra
  ( madd
  , msub
    :
  , nearly0
  , o3
  , ex3
    :
  ,
  , initPos
  , initDir
    :
  ) where
```

これで、ここに書いてある以外の定義、関数などは他から使えなくなる。
関数や定数(o3とか)も並べるだけでよい。
