# CPUの創りかた(8): すべては足し算だった

CPUの製作もいよいよゴールが近づいてきた。残る主要な部品は
命令デコーダ(instruction decorder)ぐらいか。まずはCPUの全体構造を
確認しておきたい。そうすれば命令デコーダをどう作ればいいかがよく
分かると思う。次に命令デコーダを考えよう。

#### CPUのブロック図と命令デコーダ

CPU(TD4)を入力、処理、出力に分けて考えると次のようなブロック図に
なると思う。

（図）

これを見ると、入力値(入力ポート(I/P)、A,Bレジスタ、直値)は全て加算器
(adder)に入り、結果は全て加算器から出てきて出力ポート(O/P)やレジスタに
書き込まれるような構成になっている。
前回加算器を作ったが、入力は二つの4 bit値、出力は一つの4 bit値とcarry
フラグだった。ということは、加算器に入れる値をいくつかの候補から選択する
必要がある。それが図のselector INだ。
一方加算結果を書き出す先も選択するが、これはselector OUTの仕事だ。

それでは、どれを足してどこに結果を書くかは何で決まるかというと、もちろん
命令(operation code)で決まるわけだ。ここまでくると命令デコーダの
やっていることが見えてくる。このCPU(TD4)においては、
「命令を解釈して、どの値を足すか、それをどこへ書き出すかを選択する」
ということをやっているわけだ。ROMから命令デコーダへ入っている矢印が
「命令」を、命令デコーダからselector IN/OUTへ伸びている矢印が
どれを選択するかを示す情報というわけだ。

#### すべては足し算

さて、上記の図と説明を見て違和感を感じなかっただろうか?
TD4の構造では全ての命令(処理)が加算器を通る。それはつまり「足し算しか
できない」ということだ。しかしCPUの処理というものは、代入とかポートの
入出力とか、ジャンプとかいろいろあるわけで、それはどこへ行ったんだ、
となる。

これについては例の本(CPUの創りかた)を読むとよくわかる。一見全く別の
命令に見えたものが、実は「全部足し算で表現できる」のだ。次の表を
参照してほしい。これは命令コード(opcode)とニーモニック、それに
対応する足し算を並べたものだ。

opcode|mnemonic| equation |
|:-|:-|:-|
0000xxxx|ADD A,Im|A   ← A    + Im
00010000|MOV A,B |A   ← B    + 0000
00100000|IN  A   |A   ← I/P  + 0000
0011xxxx|MOV A,Im|A   ← 0000 + Im
01000000|MOV B,A |B   ← A    + 0000
0101xxxx|ADD B,Im|B   ← B    + Im
01100000|IN  B   |B   ← I/P  + 0000
0111xxxx|MOV B,Im|B   ← 0000 + Im
10010000|OUT B   |O/P ← B    + 0000
1011xxxx|OUT Im  |O/P ← 0000 + Im
1110xxxx|JNC Im  |PC  ← 0000 + Im (cf=0)
1111xxxx|JMP Im  |PC  ← 0000 + Im

全部足し算で表現できている！恥ずかしながら今までこういうことだと
知らなかった。。。代入は足し算を使って(片方を0にして)実現しており、
出力ポートへの書き出しとは代入先がポートになっているただの代入だ。
ジャンプは飛び先アドレスをPCへ代入しているだけだ。

式中のプラス記号の左と右を比べてほしい。左のものはSelector INから来るもの、
右のものはROMから直接入ってくるものだ。左については図に書かれていない
'0000'も含まれている。これも実際に作るときにはSelector INの入力の一つと
してつくり込む必要がある。一方左側は直値(Im)か0だ。それをどうやって
使い分けているか、は考える必要がない。命令コードの下4 bitがそれだ。
0を入れたければ命令コードで0にしてあるのだ。

もちろん一般のCPUはもっと複雑な構造をしているので、
こんな単純に全部足し算で処理しているのではなく、ALU内で複雑なことを
しているのだろうが。とはいえそれも、加算器とか乗算器とか、論理演算
などを処理する部分にどういったものを入力するか、それらから出てくる
結果をどこへ書き出すかを命令デコーダが選択すればいいだろうから、
やり方は大差無いだろう。結局命令デコーダというものは、どれを
どの処理器へ入力し、どこへ書き出すかを決める「だけ」ということか。

命令デコーダは「命令を解釈する」というところで、なんとなくよく分からなくて
神秘的でとても高度なことをしているというイメージがあったのだが。
今回の製作でその辺のカラクリが見えたのは収穫だ。
(知っている人には当たり前すぎて今更何を言っている、と思われるだろうが)

#### 命令デコーダ

では、最後の大物(?)にとりかかろう。先述の通り、このCPUの命令デコーダは
「命令を解釈してSelector IN/OUTを適切に制御する」ものだ。ではSelectr INと
OUTは何者かということになる。まあ本に書いてあることだが、

* Selector IN: 4chマルチプレクサを4 bit分並べたもの。一つのマルチプレクサで
1 bit分が選択できるので4つ必要。
* Selector OUT: どのレジスタやポート(実体はFlip Flop)の`Load`を有効に
するかを指定する。実体があるわけではなく命令デコーダの一部と言える。
(わかりやすくするためSelector OUTと表現しているが)

ということだ。結局命令デコーダは、Selector IN/OUTに必要な「選択する
ための情報」を作り出せばいいのだ。

さて、命令デコーダの入力は命令コード(上4 bit、OP0-OP3)とcarryフラグ(CF)だ。
Select INへは2 bitの情報を与えてやれば良い(4種類、SA,SB)。Selector OUTの
ためには、4つある`Load`のどれか一つを有効にそれ以外を無効にする
必要があるので、4 bitの情報で表す(LD0-LD3)。まとめると、入力は5 bit
(OP0-OP3,CF)、出力が6 bit(S0,S1,LD0-LD3)だ。

SA,SBの値と選ばれる入力の対応は下表のとおり。

|SA|SB|input|
|:-|:-|:-|
|0|0|A register|
|1|0|B register|
|0|1|input port|
|1|1|value '0000'|

LD0-LD3と出力先の対応は下表のとおり。

|LOAD|output|
|:-|:-|
|LD0|A register|
|LD1|B register|
|LD2|output port|
|LD3|program counter|

これらを踏まえ入出力を真理値表にまとめたものがp.242にある。さらに
カルノー図などで分析した結果、各出力は次のように表現できる。

[tex:{
  S_A = OP_0 + OP_3
}]
[tex:{
  S_B = OP_1
}]
[tex:{
  LD_0 = OP_2 + OP_3
}]
[tex:{
  LD_1 = \overline{OP_2} + OP_3
}]
[tex:{
  LD_2 = OP_2 + \overline{OP_3}
}]
[tex:{
  LD_3 = \overline{OP_2} + \overline{OP_3} + \overline{OP_0} \cdot CF
}]

非常に簡潔になった、素晴らしい。もちろん偶然ではなく、この著者はこういう
単純な回路になるように考えて、命令コードを割り振っているわけだ。
ここまでくればコードに落とすのは簡単だ。

```haskell
{- |
instruction decorder

  IN : [OP0,OP1,OP2,OP3,CF]
  OUT: [SA,SB,LD0,LD1,LD2,LD3]

    OPn: operation code (upper 4 bit)
    CF : carry flag
    SA : Select A
    SB : Select B
    LDn: LOAD0 - LOAD3
-}

c_inst_decorder :: LogicCircuit
lc_inst_decorder (op0:op1:op2:op3:c:_) = [sa, sb, l0, l1, l2, l3]
  where
    sa = op0 |> op3
    sb = op1
    nop0 = (!>) op0
    nop2 = (!>) op2
    nop3 = (!>) op3
    l0 = op2  |> op3
    l1 = nop2 |> op3
    l2 = op2  |> nop3
    l3 = nop2 |> nop3 |> (nop0 &> c)
```


#### まとめ

今回はコードが一切出てこなかったが、次回の命令デコーダへの前振りと
いうことで。次は命令デコーダをつくり、いよいよCPUを構成しよう。



