# CPUの創りかた(4): Flip Flop

今回こそ、CPU本体の製作に入ろう。本「CPUの創りかた」では、次にレジスタを
作る流れになっているのでそれに倣う。といってもいきなりレジスタはしんどい
ので、今回はその手前のFlip Flopの話だ。
Flip Flopは順序回路の一種らしいが、ざっくりいうと過去の状態を記憶する
ことができるらしい（と習った気はするがとっくに忘れていた）。
だから「レジスタ」は値を保持できるというわけだ。

さてここで、「状態を記憶する」にはどうしたらいいのか、というところで
固まってしまった。オブジェクト指向言語であれば、オブジェクト内に状態を
持つなんてのは普通にできてしまうので何も問題ないが、使うのはHaskellで
ある。単純に作ると「状態」は持てないのではないのか?
それじゃあ作れないではないか、と思ったのだ。

HaskellにはStateモナドなるものがあり、これを使うと何かできそうな匂いは
するが解説を読んでもちっともわからないのであきらめた。仕方がないので
全ての「状態」は外で管理することに方針転換する。ROMの時もそうしたが、
毎回入力時に「状態」も合わせて入力し、出力には「状態」を含める。
そうすることで入出力は面倒だがとりあえず「状態」は回路の外で管理
できるだろう。

という方針（？）に基づき、Flip Flopを作っていくことにする。

#### SR Flip Flop

まずは基本中の基本(?)のSR Flip Flopから。「CPUの創りかた」にも多少説明は
あるのだが、もう少し詳しいことが知りたかったのでこの本も買った。

（よくわかる論理回路）

これによると、SR Flip Flopの回路図は次のとおりである。

（回路図）

回路自体は単純だが、出力(Q、Q')がフィードバックしているところをどう処置
するかである。ただ、上述の通り今回は「状態」を（関数など）内部に持たず
毎回入力するので、それほど悩まなくてもいいかもしれない。

```haskell
{- |
SR-FlipFlop

  IN : [S,R,Q,!Q]
  OUT: [Q,!Q]

-}

lc_srff :: LogicCircuit
lc_srff (s:r:q:q':_) = [x, x']
  where
    x_ = head $ lc_nand [s, q']
    x' = head $ lc_nand [r, x_]
    x  = head $ lc_nand [s, x']
```

一旦、`Q`について仮の出力を得て、それを`!Q`の方に回して`!Q`を得る。
それを入力として、あらためて`Q`を得るわけだ。なおソース中では、
`Q`は`x`、`!Q`は'x'`で表している。ちなみにこのSR Flip Flopは負論理だ。
つまりセット/リセットの時はSやRをLOにする。


SR Flip Flopの真理値表は次のようである。

|S|R|Q|!Q|remarks|
|:-|:-|:-|:-|:-|
|L|L|?|?|変化しない|
|L|H|L|H|リセット|
|H|L|H|L|セット|
|H|H|L|L|




#### エッジトリガ型 D Flip Flop

解説書などではR-Sの次は？？で、次は？？で、みたいな流れになるようだが、
ここでは一気に飛ばして「実際に使うFlip Flop」に進みたいと思う。
結局CPUで使われるのは"エッジトリガ型 D Flip Flop"だそうだ。これは、
clockの立ち上がり（or 立ち下がり）の瞬間のD入力を保持するらしい。




#### まとめ



