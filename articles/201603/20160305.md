# CPUの創りかた(6): プログラムカウンタ

前回はレジスタを作ったが、その流れでプログラムカウンタを作ろう。
なぜ「その流れ」かというと、プログラムカウンタはレジスタに少し
手を加えたものだからだ（というのは最近知ったので偉そうなことは
言えない）。

#### 命令の実行とクロック（立ち上がり）のタイミング

プログラムカウンタの前に一つ。

この記事はコードを少しずつ書きながらその状況を書いているのだが、
それでも全体構成だとか、先々のロジックとかもちらほら考えながら
進めている。それでどうしても腑に落ちなかったのが、「プログラムの
ワンステップは電子回路のどこから始めてどこで終わるのか」ということだった。

全体の流れは、命令ごとに「入力があって、命令の処理をして、出力をして」
というのを繰り返すのだろうが、入力値をCPUのどの構成部品に最初に
放り込んで進めていくか、というところで混乱してしまった。
が、最近やっとどうすればいいかわかった。要は、クロックのタイミングに
ついて完全に誤解していたのだ。

以下に、一つの命令(ワンクロック命令とする）の処理について、これまで
想像していた流れと実際の流れを示す。
(クロック=クロックの立ち上がり、結果出力=レジスタ更新など)

> * これまでの想像 *
> [クロック] => (命令フェッチ) => (デコード) => (命令実行) => (結果出力)
>
> * 実際の流れ *
> (命令フェッチ) => (デコード) => (命令実行) => [クロック] => (結果出力)

というわけで、一つの命令はほとんど最後まで処理されて最後の「締め」の
ためにクロックを待っているのだ。クロックの瞬間に結果が固定される。
さらに（個人的に）驚きなのは、レジスタ値が更新されてめでたし
と思っていたら、勝手に次の命令をどんどん処理していて結果も出ていて、
あとはレジスタなどへの書き込み待ち、というところまでノンストップで
進めてしまっていること。。。

コンピュータやCPUに詳しい方には至極当然のことだろうが、うーん、
この歳になって目から鱗だった。

#### プログラムカウンタ


#### まとめ

今回で「記憶」に関わる部分はあらかた出来上がったと思う（一部
キャリーフラグが残っているが、単にD-FFだし）。
次回からいよいよ計算（命令）のロジックに入ろうと思う。

