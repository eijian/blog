# レイトレーシング(9): フィルタ、乱数などで抗ってみる

前回は曲がりなりにもなんとかフォトンマッピング法で画像を生成できた。
ただ、生成画像には課題が多いことも分かった。もちろん作成したのはとても
「限定した仕様」に基づいたものなので一部仕方のないところもあるが、可能な限り
改善するよう抗ってみる。

と言ってはみたが、結論から述べると今回の取り組みは「そんなに有効でなかった」。
前回示した画像では、球の影がぼやけてしまったり壁の色が均一でないことを指摘した。
「限定した仕様」では影の部分にはまったくフォトンが届かないので、フォトンの密度から
輝度を求めるフォトンマッピング法では「真っ暗」な場所は表現できないのと、フォトンが
少ないとどうしても均一にならないからだ。と愚痴を言っても
仕方がないので、もがいた結果を記載する。

#### 円錐フィルタ

フォトンマッピング本の7章最後にフィルタについて言及されている。ここで言うフィルタは
輝度を求めたい点に近いフォトンの重要度を上げ、遠いフォトンは下げることである。
よって、中心に近いほど大きな係数を掛け、遠いものは小さくすることで、求めたい輝度に
関係なさそうなフォトンの影響を下げようというものである。

円錐フィルタは一次関数的に重み付けを行うもので、計算式は本に記載されているものを
そのまま使った。$w_{pc}$ は

$$w_{pc}=1-\frac{d_p}{kr}$$

$k$の値により、フィルタの効き方が変わってくるが、式から考えると$k$は
小さくても1.0まで、無限大にするとフィルタの効果が消える。例の本には$k$が1.1と
してあった。フィルタを導入するにあたり、プログラムの関係する部分を少し変更した。

```haskell
estimateRadiance :: Double -> KdTree Double PhotonInfo -> Intersection          
                 -> Radiance                                                    
estimateRadiance pw pmap (p, n, m)                                              
  | ps == []  = radiance0                                                       
  | otherwise = (1.0 / (pi * rmax * rmax)) *> (brdf m rad)                      
  where                                                                         
    ps = filter (isValidPhoton n) $ kNearest pmap nPhoton $ photonDummy p       
    rs = map (\x -> norm ((photonPos x) - p)) ps                                
    rmax = maximum rs                                                           
    rad = sumRadiance1 pw rmax rs ps                                            

-- Normal (non filter)                                                          
sumRadiance1 :: Double -> Double -> [Double] -> [PhotonInfo] -> Radiance        
sumRadiance1 pw rmax rs ps = foldl (+) radiance0 rads                           
  where                                                                         
    rads = map (photonInfoToRadiance pw) ps                                     

-- Cone filter                                                                  
k_cone :: Double                                                                
k_cone = 1.1                                                                    
fac_k :: Double                                                                 
fac_k = 1.0 - 2.0 / (3.0 * k_cone)                                              

sumRadiance2 :: Double -> Double -> [Double] -> [PhotonInfo] -> Radiance        
sumRadiance2 pw rmax rs ps = foldl (+) radiance0 rads                           
  where                                                                         
    wt = map (waitCone (pw / fac_k) rmax) rs                                    
    rads = zipWith (photonInfoToRadiance) wt ps                                 

waitCone :: Double -> Double -> Double -> Double                                
waitCone pw rmax dp = pw * (1.0 - dp / (k_cone * rmax))                         
```

`estimateRadiance`の一番下、`rad=sumRadiance1 pw rmax rs ps`としている。
この`sumRadiance1`をフィルタごとに取り替えられるようにするのだ。
フィルタ無しの場合は単にフォトンの出力を足し合わせるだけ(`sumRadiance1`)だ。

円錐フィルタでは各フォトンごとに重みを求め('waitCone')、正規化のため`fac_k`で
整えている。$k$が1.0, 1.1, 1.5での結果をフィルタ無しと並べ比較してみる。

「画像」

奥の壁の下の方、床の色が滲んでいるところがましになっているようだが、球の影については
ほとんど改善がない。結局影の部分にはフォトンがないため広い範囲から少しずつフォトンを
集めてくる結果、円錐フィルタの傾きが小さくなり、結果各フォトンの寄与具合はフィルタ無しと
たいして変わらなかったのではないか。結局、注目している交点の近辺に少しでもフォトンが
ないと効果的でないということか？逆に奥の壁は多少だがフォトンがあるため、より効果が
わかりやすかったのかもしれない。

試しに、$k$を1.0未満にするとどうなるかだが、0.8と0.67の場合も並べておいた。
0.8で荒れてきて、0.67ではもはや異次元だ・・・。

#### 遠方フォトンの排除

次に試したのがこれだ。影の部分では交点の近隣にフォトンがないため、遠方のフォトンまで
かき集めてきて放射輝度推定している。要するに影でないところのフォトンを使って影の色を
出そうとしているのだから当然無理がある。であれば、関係ない遠方のフォトンを使わなければ
いいのでは、という考えで試してみた。検証では、基本的に200個のフォトンで推定することに
した上で、推定に使うかどうかの判定時に交点からの距離の条件を追加してみた。

```haskell
radius2 = 0.1 * 0.1 :: Double                                                   
isValidPhoton :: Position3 -> Direction3 -> PhotonInfo -> Bool                  
isValidPhoton p n pi = n <.> (photonDir pi) > 0 &&                              
                       square (p - photonPos pi) < radius2                      
```

`radius2`が距離の条件である(計算速度を稼ぐため二乗してある)。本プログラムでは
長さの単位を[m]としており、サンプルのシーンは一辺が4[m]である。この状況で、
距離の条件を0.5、0.2、0.1と変えて試した結果が下図である。

「画像」

影についてだけ言えば、円錐フィルタより効果はあるように見える。`R=0.2`(20[cm])
では、古典的レイトレの影に近い感じが出ている。`R=0.1`(10[cm])だと影はかなり
くっきりしているが代わりにまだら模様がひどくて如何ともしがたい。

この方法は一定の効果が見込めるものの、強く効かせすぎると少ないフォトンでの推定に
なってしまうためノイズが大きくなってしまう。

#### メルセンヌツイスター乱数の使用

まだら模様(フォトンが均等に放射されていないことによるノイズ)を減らすためには、
フォトンを多くするか、フォトンの偏りを減らすかだと思う。フォトンを多くすると
計算時間がかかるし、そもそも少ないフォトンでもできるだけ高品質な画像を得たい。
であれば、フォトンの偏りを減らす方向で何ができるだろう？

フォトンの放射方向は乱数を使ってランダムに決めている。ただ、コンピュータでは
普通擬似乱数を使うため、その乱数としての質が気になる。であれば質が良い乱数を
使えばどうか?ということでメルセンヌツイスターなる乱数を使ってみることにした。

http://qiita.com/philopon/items/8f647fc8dafe66b7381b
http://www.math.sci.hiroshima-u.ac.jp/%7Em-mat/MT/mt.html

`cabal`でのインストールは下記のようにすれば良い。

```
$ cabal install mersenne-random
```

フォトン放射の際に方向ベクトルを生成するが、そのルーチンを標準の乱数ライブラリの
場合と比べてみる。まずは標準ライブラリ。

```haskell
import System.Random
  (中略)

generateRandomDir2 :: IO Direction3
generateRandomDir2 = do
  x <- randomRIO (-1.0, 1.0)
  y <- randomRIO (-1.0, 1.0)
  z <- randomRIO (-1.0, 1.0)
  let v = initPos x y z
      len = norm v
  if len > 1.0 || len == 0.0
    then generateRandomDir2
    else return $ fromJust $ normalize v
```

次にメルセンヌツイスターの場合。

```haskell
import System.Random.Mersenne as MT
  (中略)

generateRandomDir3 :: IO Direction3
generateRandomDir3 = do
  x' <- MT.randomIO :: IO Double
  y' <- MT.randomIO :: IO Double
  z' <- MT.randomIO :: IO Double
  let x = x' * 2.0 - 1.0
      y = y' * 2.0 - 1.0
      z = z' * 2.0 - 1.0
      v = initPos x y z
      len = norm v
  if len > 1.0 || len == 0.0
    then generateRandomDir3
    else return $ fromJust $ normalize v
```

実数で生成した場合0.0〜1.0の範囲の実数になるようなので、わざわざ-1.0〜1.0に
変換しないといけない。が、まあ大した手間ではない。

標準`random`とMTについて乱数の性質を比較してみよう。上記の`generateRandomDir2/3`
で方向ベクトルを10000個生成し、

-1.0〜1.0の間にある
実数を両乱数ライブラリで3つ生成し、各実数を要素とした3次元ベクトルを正規化した
ものを多数足し合わせよう。偏りが少ないほど、足し合わせた結果は原点に近くなる
はずだ（と思う）。

#### まとめ
