# レイトレーシング(9): フィルタ、乱数などでもがいてみる

前回は曲がりなりにもなんとかフォトンマッピング法で画像を生成できた。
ただ、生成画像には課題が多いことも分かった。もちろん作成したのはとても
「限定した仕様」に基づいたものなので一部仕方のないところもあるが、可能な限り
改善するようもがいてみる。

と言ってはみたが、結論から述べると今回の取り組みは「そんなに有効でなかった」。
前回示した画像では、球の影がぼやけてしまったり壁の色が均一でないことを指摘した。
「限定した仕様」では影の部分にはまったくフォトンが届かないので、フォトンの密度から
輝度を求めるフォトンマッピング法では「真っ暗」な場所は表現できないのと、フォトンが
少ないとどうしても均一にならないからだ。と愚痴を言っても
仕方がないので、もがいた結果を記載する。

#### 円錐フィルタ

フォトンマッピング本の7章最後にフィルタについて言及されている。ここで言うフィルタは
輝度を求めたい点に近いフォトンの重要度を上げ、遠いフォトンは下げることである。
よって、中心に近いほど大きな係数を掛け、遠いものは小さくすることで、求めたい輝度に
関係なさそうなフォトンの影響を下げようというものである。

円錐フィルタは一次関数的に重み付けを行うもので、計算式は本に記載されているものを
そのまま使った。

[tex:]

[tex: k]の値により、フィルタの効き方が変わってくるが、式から考えると[tex: k]は
小さくても[tex: 1.0]まで、無限大にするとフィルタの効果が消える。本では[tex: k=1.1]と
してあった。フィルタを導入するにあたり、プログラムの関係する部分を少し変更した。

```haskell
estimateRadiance :: Double -> KdTree Double PhotonInfo -> Intersection          
                 -> Radiance                                                    
estimateRadiance pw pmap (p, n, m)                                              
  | ps == []  = radiance0                                                       
  | otherwise = (1.0 / (pi * rmax * rmax)) *> (brdf m rad)                      
  where                                                                         
    ps = filter (isValidPhoton n) $ kNearest pmap nPhoton $ photonDummy p       
    rs = map (\x -> norm ((photonPos x) - p)) ps                                
    rmax = maximum rs                                                           
    rad = sumRadiance1 pw rmax rs ps                                            

-- Normal (non filter)                                                          
sumRadiance1 :: Double -> Double -> [Double] -> [PhotonInfo] -> Radiance        
sumRadiance1 pw rmax rs ps = foldl (+) radiance0 rads                           
  where                                                                         
    rads = map (photonInfoToRadiance pw) ps                                     
                                                                                
-- Cone filter                                                                  
k_cone :: Double                                                                
k_cone = 1.1                                                                    
fac_k :: Double                                                                 
fac_k = 1.0 - 2.0 / (3.0 * k_cone)                                              
                                                                                
sumRadiance2 :: Double -> Double -> [Double] -> [PhotonInfo] -> Radiance        
sumRadiance2 pw rmax rs ps = foldl (+) radiance0 rads                           
  where                                                                         
    wt = map (waitCone (pw / fac_k) rmax) rs                                    
    rads = zipWith (photonInfoToRadiance) wt ps                                 
                                                                                
waitCone :: Double -> Double -> Double -> Double                                
waitCone pw rmax dp = pw * (1.0 - dp / (k_cone * rmax))                         
```

`estimateRadiance`の一番下、`rad=sumRadiance1 pw rmax rs ps`としている。
この`sumRadiance1`をフィルタごとに取り替えられるようにするのだ。
フィルタ無しの場合は単にフォトンの出力を足し合わせるだけ(`sumRadiance1`)だ。

円錐フィルタでは各フォトンごとに重みを求め('waitCone')、正規化のため`fac_k`で
整えている。[tex: k=1.5, 1.1, 1.0]での結果をフィルタ無しと並べ比較してみる。

「画像」

確かに少しましにはなっているようだが、明確な影を表現するには程遠い。
ちなみに、[tex: k]を1.0未満にするとどうなるかだが、0.8と0.67の場合を
示す。0.8で荒れてきて、0.67ではもはや異次元だ・・・。

「画像」

#### ガウスフィルタ

ガウスフィルタはフィルタにガウス分布を使うものだ。円錐フィルタと同様に交点に
近いフォトンほど輝度への寄与を強く、遠いほど弱くするものだ。正規分布の一般的な
形を考えれば、円錐フィルタほど急な変化はないが、ある程度遠いフォトンはほとんど
影響を与えないということでは円錐フィルタより質が良いかもしれない。ということで
下記のようなコードで試してみた。

```haskell
-- Gauss filter                                                                 
                                                                                
alpha = 1.953                                                                   
beta  = 0.918                                                                   
e_beta = 1.0 - exp (-beta)                                                      
                                                                                
sumRadiance3 :: Double -> Double -> [Double] -> [PhotonInfo] -> Radiance        
sumRadiance3 pw rmax rs ps = foldl (+) radiance0 rads                           
  where                                                                         
    wt = map (waitGauss pw rmax) rs                                             
    rads = zipWith (photonInfoToRadiance) wt ps                                 
                                                                                
waitGauss :: Double -> Double -> Double -> Double                               
waitGauss pw rmax dp = pw * alpha * (1.0 - e_r / e_beta)                        
  where                                                                         
    e_r = 1.0 - exp (-beta * dp * dp / (2.0 * rmax * rmax))                     
```

なお、「フォトンマッピング」本に記載の[tex: \alpha=0.918, \beta=1.953]は
[tex: \alphaと\beta]が逆である。これに気づかず実行したら、フィルタ無しや
円錐フィルタの時に比べ画像が暗くなってしまった。明るさは（ほぼ）同じにならないと
おかしいのでかなり悩んだが、記載の式(下記)で交点と同じ位置のフォトンが
1.0を下回るのはどう考えてもおかしい（全部足し合わせてもフィルタ無しより絶対に
小さくなる）ので[tex: \alpha,\beta]を取り替えてみたらうまくいったわけだ。

[tex: {
  w_pg=\alpha [1-{1-e^{-\beta^{d_p^2}/{2r^2}}}/{1-e^{-\beta}}]
}]

そう考えるとそれぞれの数値の意味が見えてきて、[tex: \beta = 0.918]は
「平均・分散とも未知の場合の2.5%有意水準」を表しているようだ。
[tex: \alpha]の方はたぶん結果を正規化(明るさをフィルタ無しの場合と揃える
ということだ)するための補正係数だろう。

#### メルセンヌ乱数


#### 遠方フォトンの排除


#### おわりに





