# CPUの創りかた(3): ROMを創る

今回はROMを創ろう。ROMと言っても「CPUの創りかた」本ではディップスイッチで
代用している。つまり論理回路ではない。ということでここでも論理回路の
シミュレーションは諦め（笑）、単純にHIかLOを出すような関数を作ろうと思う。

まずはROMの回路図の概要を示す。今回作っていく各関数がどこに当たるかも
コメント入れておく。

（図）

#### ROMモジュールの入出力

まずはこのROMモジュールの入力と出力を決めよう。ROMに対しては
取り出したいアドレス（番地）を指定したらいいだろう。このROMは16バイトなので
0番地から15番地まである。これを二進数で指定するため、4 bitの入力値が必要だ。
下位の桁からA0,A1,A2,A3とする。

ところでROMの内容はどこに存在するのだろう？物理的なディップスイッチであれば、
スイッチを一つ一つカチカチやっていけばいいが、今回はどうしたものか。
"ROM"ということなら、haskellソース中に定数として定義してもいいのだが、
それだと「プログラム」を変更するのに毎回コンパイルし直さないといけないので
格好悪すぎる。実行時に読み込ませるようにしよう。読み込んだものを
保管しておきこのモジュール内部で読み込ませる手もあるが、今回はROMモジュール
への入力として毎回指定する形にしたい。これは、後々レジスタなどについても
同様なのだが、CPUの「状態」をモジュールの外で管理しておこうと考えて
いるからだ。それが良い方法なのかどうかは疑問だが、あまりいい手が思い浮かばない
ので。

ということで、16バイトの2進数も入力にする。0番地の最下位bit(D00)から順に、
15番地の最上位bit(Df7)までの128 bit(2桁目が番地、3桁目が1バイト中の位置)。
ただ、128 bitに満たない入力も"0"を補填して16バイトになるようにする。

出力はというと、これは簡単だ。A0-A3で指定した番地のROMの値1バイトが
モジュールから出てくる。Y0,Y1,..Y7だ。こちらも最下位bitから始まることに
注意する。

#### 番地の指定

まずROMモジュールの全体を示そう。関数名は`lc_rom16`とする。

```haskell
lc_rom16 :: LogicCircuit
lc_rom16 xs = lc_not $ concat $ map (\x -> mergeBits x omem) [0..7]
  where
    adr = lc_decorder4 $ take 4 xs
    mem = split8 $ take (8*16) ((drop 4 xs) ++ repeat sLO)
    omem = map toSwitch (zip adr mem) -- out of switches (16 bytes)
```

先の回路図とこの関数中で使われているサブ関数を対応させながら
何をやっているか書いてみる。このモジュールの入力は、番地を指定する
4 bitと、ROMの中身128 bitの計132 bit分のBinのリストである。
まずは番地指定とROMとを分解する。番地は先頭の4要素であるから、
`take 4 xs`で取り出せる。これにさらに前回作ったdecorder(4 bit)を
適用すれば、16要素のリストを得る。この中身は、指定した番地に該当する
要素だけがLO、他はHIとなるのだった（前回参照）。それが下記の部分だ。

```haskell
    adr = lc_decorder4 $ take 4 xs
```

回路図の左のほうがこれにあたる。

#### ROMデータの整形

次は、今後の処理をしやすくするため128 bitのROMデータを整形しよう。
具体的には、128 bitに足りない分を補填し、8 bit毎に区切ったリストにする。

* まずROMデータの取り出しに`drop`を使う（`drop 4 xs`）。
* さらに補填のためその後ろに「無限に続くLO」をつける(` ++ repeat sLO`)。
* 続けてそれの先頭から128個を取り出す（`take (8*16) ...`)。
* 最後に8こずつに切り分けて16要素のリストにする(`split8 ...`)。

ここで、`split8`は次のようにした。

```haskell
split8 :: [Bin] -> [[Bin]]
split8 [] = []
split8 xs
  |length xs < 8 = [take 8 (xs ++ repeat sLO)]
  |otherwise     = l:(split8 ls)
    where
      l  = take 8 xs
      ls = drop 8 xs
```

念のため入力が8 bitに満たないときは後ろにLOを補填するようにしているが。
これでROMデータを16番地の"バイト列"に分けることができた。
回路図における16個のディップスイッチが構成できた。

#### 各ディップスイッチからの出力

このディップスイッチの構造は8個の物理的スイッチの集まりと言える。
スイッチONで導通、OFFで不通だ。出力側をHIに繋いだ時、入力値と
スイッチの状態との組み合わせで4パターンあるが、それぞれの出力は
下図の通りである。

（図）

これで分かるように、スイッチの状態を出力するにはLOを入力しないと
いけないということだ。アドレスの指定はdecorderを経て16個の出力に
なり、そのうち一つだけがLOであとはHIになるのだった。そう、これにより
LOになった線につながるスイッチの出力だけが「有効」になるわけだ。

そのためdecorderの各出力線と各番地を対応させる処理が次の部分だ。

```haskell
    omem = map toSwitch (zip adr mem) -- out of switches (16 bytes)
```

`zip`により出力線と番地を組み合わせ、`toSwitch`へ放り込んでいる。
その実装は次の通り。

```haksell
toSwitch :: (Bin, [Bin]) -> [Bin]
toSwitch (a, ms) = lc_dipswitch (a:ms)

lc_dipswitch :: LogicCircuit
lc_dipswitch (a:xs)
  | a == sHI = take 8 $ repeat sHI
  | a == sLO = take 8 ((lc_not xs) ++ repeat sHI)
```

単にタプルをリストに構成しなおしてスイッチ`lc_dipswitch`へ入力しているだけ。
スイッチでの処理は、最初の入力値(decorderからくる情報)によって
二種類に分かれている。HIの時はスイッチの状態は無視して8 bit全部がHIに
なる。LOの時は番地の情報を"反転"させて出している。後ろに`repeat sHI`が
続いているが、これは入力が8個に満たなかった時の備えである。
普通HIを1、LOを0などで表すが、スイッチは導通がON、普通がOFFであり、
導通時にLOになるような回路にしたのだ。一方で関数`lc_dipswitch`の
入力は一般的な1=HI、0=LOとして与えることにした。だから中で反転させる
必要がある。

#### 各ディップスイッチからの出力の統合

さて問題は各ディップスイッチからの出力を最終的にROMモジュールの
出力にするところだ。指定した番地のスイッチからは設定されたROMの
値が(反転して)出てくるが、他のスイッチからは全部HIの値が出てくる。
欲しいスイッチの出力だけを出力につなげられればいいが、そういうわけ
にもいかない。例の本の回路図では単に全スイッチの同じbit位置の
出力を統合している(黒丸で示されている)。これは実際にはどのような値に
なるのか考えてみる。

統合する出力線は16本だ。全てがHIならHIを出せば良い。しかし取り出したい
番地のスイッチからはHI/LOのどちらかが出てくる。この値は「そのまま」
取り出したい。だから16本のうち一つでも(一つしかないはずだが)LOなら
LO、全部HIならHIが出るようにするような論理ゲートといえば、ANDだ!

各スイッチの同じbit位置を取り出してANDでまとめる処理を`mergeBits`と
した。実装は次の通り。

```haskell
mergeBits :: Int -> [[Bin]] -> [Bin]
mergeBits n ms = lc_and $ map (!!n) ms
```

第一引数がbit位置(0から7)、第二引数は全番地からの出力のリスト(16要素)。
`map`でリストから始定位置の値を取り出すので、結果は16要素のリストになる。
これを`lc_and`でまとめるわけだ。

#### 最終結果!

最後は統合された値を正論理に戻してあげればよい。回路図のいちばん右の
部分に相当する。これはディップスイッチが負論理(?)であるからだ。
これが次の部分。

```haskell
lc_not $ concat $ map (\x -> mergeBits x omem) [0..7]
```

さあ、これでほしい番地のROMデータ値が取り出せる!









