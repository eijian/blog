# レイトレーシング(10): 拡散反射と面光源

DeepLearning回からだいぶ間があき、さらにレイトレーシングは1年半以上も
時間が空いてしまった。それは拡散反射でとある処理の解法で壁にぶつかって
いたからだ。それが非常に簡単に解決できるとわかったのでちょっと進める
ことにした。

## 0. 前回まで

前回までで、フォトンマッピング法を用いたレイトレーシングプログラムを
作成した。といってもフォトン追跡は何か物体にぶつかったらそれでおしまい、
反射は未対応という中途半端な状態だ。

久しぶりなので気分を一新して新しいシーンに変えてみよう。
実は(このページ)[http://area.autodesk.jp/column/tutorial/3ds_max_kitchen_stadium/5_rgb_level/]のパクリだ。この連載は本当に参考にさせていただいている。
売り物の3DCGソフトを使っての説明だが理論的なところが詳しくよくわかる。

さて、前回までで作ったフォトンマッピングプログラムと古典レイトレーシングで
描画したものを示す。

（図）

一目瞭然、フォトンマッピングのほうは影がぼやけてしまう。
点光源なので影は古典版のようにくっきりとした縁、かつ真っ黒でなければ
ならない。前の記事でも書いたがフォトンマッピングはある点の周囲のフォトンを
集計して輝度を計算するので、影のなかにフォトンがないともっと広い
ところから集めてしまうのだ。

ということでさらの前回のおさらいだが、フォトンを集めてくる範囲を
限定して描画してみる。設定は0.2 [m]だ。それより外のフォトンは無視して
輝度を判定する。

（図）

残念ながら影の縁はぼやけてしまうが、上の画像よりははるかに本物っぽい。
今後はひとまずフォトン収集範囲を0.2 [m]として色々試すことにしよう。
ちなみにフォトン数は20万個、これでも残念ながらまだら模様になるのは
今は我慢しよう。

なおフォトンマッピングと古典レイトレーシングでは輝度の計算方法が全く
異なるわけだが、両者の明るさや色の加減はほぼ同等であることに注意したい。
レイトレーシングといっても要するに物理（光学）シミュレーションなので
同じ設定なら（ほぼ）同じ結果が出てこないといけないのだ。その点で、
ひとまずここまでは両者のプログラムに大きな間違いはなさそうだ。

## 1. 拡散反射

さあ本題の拡散反射である。現時点ではシーン中の全物体は完全拡散反射面
であるとしているので、フォトン追跡においてフォトンが物体にぶつかったら
フォトンマップに記録してから別方向へ反射させればよい。ところが長い間
詰まっていたのはその反射方向をどうするか、であった。

### (1) 拡散反射方向ベクトル

完全拡散反射面ではフォトンが物体にぶつかるとその面の半球状のいずれかに
等確率で反射する。当初は、まず上方向の平面を考え、半球のどこかへ向かう
ベクトルを求めてからそれを法線方向によって回転させようとした。

（図）

反射ベクトルは点光源でのフォトン放射でランダムに生成した経験から、それを
上半分だけにすれば生成できる。あとは回転だが、回転行列を作るのか四元数を
使うのか、よく分からないまま止まっていた。一般的にどうしているのか検索も
してみたがどうもそれらしい情報を見つけられない。

あるとき極めて容易に生成できる方法に気がついた。球状のランダムなベクトルを
生成したあと、求めたい面の法線との角度が90度以下ならそのまま採用、90度
以上なら反転させればいいのだ。

（図）

なんと簡単なことに長時間悩んだことか。恥ずかしくなるぐらいだ。。。
この処理をコードにすると次の通り。`generateRandomDir?`は以前作って
いたもの(生成方法により四種類あり、?はその番号、一例として四番目を示す)。

```Algebra.hs
generateRandomDir4 :: IO Direction3
generateRandomDir4 = do
  y' <- MT.randomIO :: IO Double
  p' <- MT.randomIO :: IO Double
  let y = y' * 2.0 - 1.0
      p = p' * 2.0 * pi
      r = sqrt (1 - y * y)
      x = r * (cos p)
      z = r * (sin p)
      v = initPos x y z
      len = norm v
  return $ fromJust $ normalize v
```

`diffuseReflection`が反射ベクトルの生成だ。

```Geometry.hs
diffuseReflection :: Direction3 -> IO Direction3
diffuseReflection n = do
  d <- generateRandomDir4
  let cos = n <.> d
  return $ if cos > 0.0 then d else negate d
```

こんなたった数行でできることに長期間悩まされていたとは・・・。

### (2) フォトンの反射

反射方向ベクトルを作ることができたので、フォトン追跡にも手を
入れよう。従来の追跡処理は次のようであった。

* フォトンの進行方向にある物体についてその距離を取得
* フォトンより前にあるものの中から最も近いものを選ぶ
* `PhotonCache`として返す。

コードはこちら。

```
tracePhoton :: [Object] -> Photon -> IO [PhotonCache]
tracePhoton os (wl, r) = do
  let iss = filter (\x -> fst x > nearly0) (concat $ map (calcDistance r) os)
      (t, s) = head $ sortBy (comparing fst) iss
  return [(wl, initRay (target t r) (getDir r))]
```

ここは大幅に変更している。やりたいことは次の通り。

* フォトンがぶつかる最初の物体との交点を得る(`calcIntersection`)
* ぶつからなければ空リストを返す。
* ロシアンルーレット法を使い物体の反射率以下なら反射(`reflect`)し
  さらにフォトン追跡をして`PhotonCache`情報を得る。
* 反射率以上ならフォトンが吸収されたとして追跡を止める。
* 交点が拡散反射面(*1)ならその点の`PhotonCahce`情報を作成する。
* 交点および反射方向の全`PhotonCache`情報を集めて返す。

(*1)について、今の所物体は全部拡散反射面という前提だが将来の拡張のため
このような判定を入れている。コードは次の通り。

```Tracer.hs
tracePhoton :: [Object] -> Int -> Photon -> IO [PhotonCache]
tracePhoton os l (wl, r) = do
  let is = calcIntersection r os
  if is == Nothing
    then return []
    else do
      let (p, n, m) = fromJust is
      i <- russianRoulette wl [reflectance m]
      pcs <- if i > 0
        then reflect p n os l wl
        else return []
      if diffuseness m > 0.0
        then return $ ((wl, initRay p (getDir r)) : pcs)
        else return pcs

reflect :: Position3 -> Direction3 -> [Object] -> Int -> Wavelength
        -> IO [PhotonCache]
reflect p n os l wl = do
  dr <- diffuseReflection n
  let r' = initRay p dr
  pcs <- tracePhoton os (l+1) (wl, r')
  return pcs
```

なお、後々の拡張のため、反射回数を引数に追加している(`l`)。
ちなみに`russianRoulete`はこのようになっている。

```Physics.hs
russianRoulette :: Wavelength -> [Color] -> IO Int
russianRoulette wl cs = do
  r <- MT.randomIO :: IO Double
  return $ rr wl cs 0.0 r (length cs)

rr :: Wavelength -> [Color] -> Double -> Double -> Int -> Int
rr _ [] _ _ len = len
rr wl (c:cs) c0 r len
  | r < c'    = len
  | otherwise = rr wl cs c' r (len - 1)
  where
    c' = c0 + selWl wl c
    selWl :: Wavelength -> Color -> Double
    selWl Red   (Color r _ _) = r
    selWl Green (Color _ g _) = g
    selWl Blue  (Color _ _ b) = b
```

まず[0,1]の一様乱数`r`を作り、`Color`のリストから指定の波長の値を取り出して
その`r`を上回ったところでリスト要素の順番(逆順)を返す。
言葉で書いても分かりにくいので例を示す。物質の反射率、透過率が次のようで
あったとする。

> 反射率: 赤=0.2、緑=0.6、青=0.4
> 透過率: 赤=0.5、緑=0.1、青=0.6

各色の率を合計1.0を超えないものとする(コードではエラーチェック
していないが)。1.0-各色の合計は吸収率を表す。今判定したいのは赤の場合、
`r`が0.6であれば、

* 1番目の要素は反射率=0.2と比べると`r`が大きいので次の要素へ
* 2番目の要素は反射率=0.5だが先の0.2とあわせて0.7として`r`と比較、
  今度は`r`が小さいのでこの時の順番は2-1で1。

ということで1になる。もし`r`が0.1なら1番目でしたまわるので結果は2だ。
この番号は、先のフォトン追跡の際に吸収、反射、透過のいずれなのかを
判断するのに使っており、このプログラムでは0=吸収、1=反射、2=透過と決めた。
なので、`russianRoulette`の返値が0より大きければフォトンを反射して
さらに追跡するようになっている。

```
      i <- russianRoulette wl [reflectance m]
      pcs <- if i > 0
        :
```

さて、それでは画像を生成してみよう。

### (3) 間接光の効果はすごい

拡散反射機能がついたので、あらためてフォトンマップを生成する。

```shell
$ cabal build
  :
$ dist/build/pm/pm > scene1.map
$ dist/build/rt/rt < scene1.map > scene1.ppm

以下に、機能拡張したプログラムで生成した画像と比較のための
古典版を示す。古典版はいわゆる「環境光」に2 [mW]の輝度を与えた。

（図）

結果は明らかだ。まだら模様と影の縁がぼやけているのは仕方ないとして、

* 球の下の方は床からの照り返しでほんのり明るくなっている
* 球の左右はそれぞれ赤・青の壁からの反射で少し赤み・青みがかっている
* 天井も壁からの照り返しがある

など、だいぶリアルな画像が得られたと思う。まだら模様もまあいわゆる
「味わい」と言えなくもない（と自分を慰めてみる）。

## 2. 面光源

さて、拡散反射による間接光が思いの外いい効果を出せたので、もう少し
拡張してみる。先の例では点光源なのに影の縁がぼやけていた。でも大きさの
ある光源ならぼやけていて当たり前、違和感がないはずだ。

ということで実装が簡単そうな平面光源を追加してみる。

### (1) 平面光源

点光源は一点から球状のあらゆる方向へフォトンが放射されるが、面光源は
面のそれぞれの点から半球状に放射される。そう、拡散反射の実装で反射光
ベクトルを求めたがそれがそのまま使える。


### (2) 平行光源

## 3. まとめ


---
ここまでのソースは(こちら)[https://github.com/eijian/raytracer/tree/version-2.1.0.0]。


